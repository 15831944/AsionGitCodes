<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- 這篇文章由Dancingwind翻譯，作者的聯繫方式zhouwei02@mails.tsinghua.edu.cn -->
<HTML>
<!-- Mirrored from www.alucardma.com/dancingwind/OpenGL/Nehe/Course/Tutorial_44.htm by HTTrack Website Copier/3.x [XR&CO'2006], Sat, 25 Nov 2006 10:05:07 GMT -->
<HEAD><TITLE>NeHe OpenGL教程第四十四課，DancingWind翻譯</TITLE>
<meta http-equiv="Content-Type" content="text/html; charset=big5">
<style type=text/css>
A:active {
	BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: #bbccff; TEXT-DECORATION: none
}
A:link {
	BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: #bbccff; TEXT-DECORATION: none
}
A:visited {
	BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: #bbccff; TEXT-DECORATION: none
}
A:hover {
	BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: #ffda6a; TEXT-DECORATION: none
}
BODY {
	COLOR: #ffffff; BACKGROUND-COLOR: #000000
}
TD IMG {
	DISPLAY: block
}
.back {
	BACKGROUND: #000022; COLOR: #ffffff
}
.back2 {
	BACKGROUND: #000000; COLOR: #ffffff
}
.back3 {
	BACKGROUND: #000022; COLOR: #ffffff
}
.copy {
	FONT-SIZE: 11px; LINE-HEIGHT: normal; FONT-STYLE: normal; FONT-FAMILY: Tahoma, Verdana, sans-serif; FONT-VARIANT: normal; TEXT-DECORATION: none
}
.head {
	FONT: bold 13px Tahoma, Verdana, sans-serif; TEXT-DECORATION: none
}
.link {
	FONT-SIZE: 14px; LINE-HEIGHT: normal; FONT-STYLE: normal; FONT-FAMILY: Tahoma, Verdana, sans-serif; FONT-VARIANT: normal; TEXT-DECORATION: none
}
.menu {
	FONT: bold 17px Tahoma, Verdana, sans-serif; TEXT-DECORATION: none
}
.news {
	BACKGROUND: #00008b; COLOR: #ffffff
}
.tab {
	PADDING-LEFT: 35px
}
.text {
	FONT-SIZE: 12px; LINE-HEIGHT: normal; FONT-STYLE: normal; FONT-FAMILY: Tahoma, Verdana, sans-serif; FONT-VARIANT: normal; TEXT-DECORATION: none
}
.theme {
	BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: #bbccff
}
.dotted {
	BORDER-RIGHT: #00008b 2px dotted; BORDER-TOP: #00008b 2px dotted; BORDER-LEFT: #00008b 2px dotted; BORDER-BOTTOM: #00008b 2px dotted
}
.solid {
	BORDER-RIGHT: #ffffff 1px solid; BORDER-TOP: #ffffff 1px solid; BORDER-LEFT: #ffffff 1px solid; BORDER-BOTTOM: #ffffff 1px solid
}
.logo {
	BACKGROUND-IMAGE: url(../graphics/rgb/logo.html)
}
.menubar {
	BACKGROUND-IMAGE: url(../graphics/rgb/menubar.html)
}
.menubg {
	BACKGROUND-IMAGE: url(../graphics/rgb/menubg.html)
}
.menuheading {
	BACKGROUND-IMAGE: url(../graphics/rgb/menuheading.html)
}
.nehebutton {
	BACKGROUND-IMAGE: url(../graphics/rgb/nehebutton.html)
}
.newslogo {
	BACKGROUND-IMAGE: url(../graphics/rgb/newslogo.html)
}
.tinylogo {
	BACKGROUND-IMAGE: url(../graphics/rgb/border/tinylogo.html)
}
.bc {
	BACKGROUND-IMAGE:  url(../Pic/bc.png)
}
.bl {
	BACKGROUND-IMAGE:  url(../Pic/bl.png)
}
.br {
	BACKGROUND-IMAGE:  url(../Pic/br.png)
}
.c {
	BACKGROUND-IMAGE: url(../Picc.html)
}
.l {
	BACKGROUND-IMAGE:  url(../Pic/l.png)
}
.lc {
	BACKGROUND-IMAGE: url(../Piclc.html)
}
.r {
	BACKGROUND-IMAGE:  url(../Pic/r.png)
}
.rc {
	BACKGROUND-IMAGE: url(../Picrc.html)
}
.tc {
	BACKGROUND-IMAGE:  url(../Pic/tc.png)
}
.tl {
	BACKGROUND-IMAGE:  url(../Pic/tl.png)
}
.tr {
	BACKGROUND-IMAGE:  url(../Pic/tr.png)
}

</style>
</head>
<BODY text=white vLink=#aaccff link=#aaccff bgColor=black>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tinylogo width=326 height=130><IMG height=130 
      alt="NeHe Productions" 
      src="../Pic/logo.png" width=326></TD>
      <TD vAlign=center align=middle><div align="center"><FONT class=text><FONT class=theme 
      size=+3><B><I>第44課</I></B></FONT></FONT></div></TD>
  </TR></TBODY></TABLE>
  <!-- 上邊框-->
<table border="0" cellPadding="0" cellSpacing="0" width="100%">
<TBODY>
  <tr>
    <td><img height="28" src="../Pic/tl.jpg" width="28"></td>
    <td width="100%"><img height="28" src="../Pic/tc.gif" width="100%"></td>
    <td><img height="28" src="../Pic/tr.gif" width="28"></td>
  </tr>
</TBODY>
</table>

<!-- 中部-->
<table border="0" cellPadding="0" cellSpacing="0" width="100%">
<TBODY>
  <tr>
  	<!-- 中部左邊框-->
    <td  background="../Pic/l.gif"><img src="../Pic/l.gif" width="28" height="28"></td>
	<!-- 中部文字部分-->
    <td vAlign="top" width="100%">
	<table width="100%" border="0">
          <tr>
            <td width="20%"><img src="../Pic/lesson44.jpg" width="160" height="120"></td>
            <td width="80%"><p><font ><b>3D 光暈</b></font><font size="2"><b></b></font></p>
              <p><font size="3">當鏡頭對準太陽的時候就會出現這種效果，模擬它非常的簡單，一點數學和紋理貼圖就夠了。好好看看吧。</font></p></td>
          </tr>
     </table>
      </td>
	<!-- 中部右邊框-->
    <td background="../Pic/r.gif"><img src="../Pic/r.gif" width="28" height="28"></td>
  </tr>
</TBODY>
</table>

<!-- 下邊框-->
<table border="0" cellPadding="0" cellSpacing="0" width="100%">
<TBODY>
  <tr>
    <td><img height="28" src="../Pic/bl.gif" width="28"></td>
    <td width="100%"><img height="28" src="../Pic/bc.gif" width="100%"></td>
    <td><img height="28" src="../Pic/br.gif" width="28"></td>
  </tr>
</TBODY>
</table>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
      <TD class=back3 vAlign=top width="100%">大家好,歡迎來到新的一課,在這一課中我們將擴展glCamera類，來實現鏡頭光暈的效果。在日常生活中，當我們對著光源看時，會發現強烈的反光。<br>
        為了完成這個效果，我們需要一些數學知識。首先，我們需要一些函數，用來檢測某個點或球是否在當前的視景體內。接著我們需要一些紋理作為我們的光暈效果，我們可以把它貼在顯示面上。
<p>在我的上一個攝像機類裡把下面函數寫錯了，現在修正如下：</p>
    </TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE>void glCamera::SetPrespective()<br>{<br>	GLfloat Matrix[16];												<br>	glVector v;														<br>																	</PRE>
<p> <span class="theme">// 根據當前的偏轉角旋轉視線</span><br>
  glRotatef(m_HeadingDegrees, 0.0f, 1.0f, 0.0f);<br>
  glRotatef(m_PitchDegrees, 1.0f, 0.0f, 0.0f);</p>
<p> <span class="theme">// 返回模型變換矩陣</span><br>
  glGetFloatv(GL_MODELVIEW_MATRIX, Matrix);</p>
<p> <span class="theme">// 獲得視線的方向</span><br>
  m_DirectionVector.i = Matrix[8];<br>
  m_DirectionVector.j = Matrix[9];<br>
  m_DirectionVector.k = -Matrix[10];</p>
<p> <span class="theme">// 重置矩陣</span><br>
  glLoadIdentity();</p>
<p> <span class="theme">// 旋轉場景</span><br>
  glRotatef(m_PitchDegrees, 1.0f, 0.0f, 0.0f);<br>
  glRotatef(m_HeadingDegrees, 0.0f, 1.0f, 0.0f);</p>
<p> <span class="theme">// 設置當前攝像機的位置</span><br>
  v = m_DirectionVector;<br>
  v *= m_ForwardVelocity;<br>
  m_Position.x += v.i;<br>
  m_Position.y += v.j;<br>
  m_Position.z += v.k;</p>
<p> <span class="theme">// 變換到新的位置</span><br>
  glTranslatef(-m_Position.x, -m_Position.y, -m_Position.z);<br>
  }</p>
<p></p>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
      <TD class=back3 vAlign=top width="100%"> <p>好了，我們現在開始吧。我將使用4個對立的紋理來製造我們的鏡頭光暈，第一和二個光暈圖像被放置在光源處，第三和第四個圖像將根據視點的位置和方向動態的生成。紋理的圖像如下所示：</p>
      <table align=center border=0>
        <tbody> 
        <tr> 
          <td align=middle><font class="text">Big Glow<br>
            <br>
            <img 
            src="../Pic/big_glow.jpg" width="128" height="128"></font></td>
          <td width=100>&nbsp;</td>
          <td align=middle><font class="text">Streaks<br>
            <br>
            <img 
            src="../Pic/streaks.jpg" width="128" height="128"></font></td>
        </tr>
        <tr> 
          <td align=middle><font class="text">Glow<br>
            <br>
            <img 
            src="../Pic/glow.jpg" width="64" height="64"></font></td>
          <td width=100>&nbsp;</td>
          <td align=middle><font class="text">Halo<br>
            <br>
            <img 
            src="../Pic/halo.jpg" width="64" height="64"></font></td>
        </tr>
        </tbody>
      </table>
      <p>&nbsp;</p>
      <p>&nbsp;</p>
        <p>現在你在頭腦裡應該有了一個大慨地圖像了吧。我們來說說何時我們應該繪製光暈，一般來說平時我們是看不見這些光暈的，只有當我們對準光源的時候才能看見這些。所以我們首先要獲得視景體的數據，下面的函數可以幫我們完成這個功能。</p>
    </TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE><span class="theme">// 獲得當前視景體的6個平面方程的參數</span><br>void glCamera::UpdateFrustum()<br>{<br>    GLfloat   clip[16];<br>	GLfloat   proj[16];<br>    GLfloat   modl[16];<br>    GLfloat   t;</PRE>
<p> <span class="theme">//返回投影矩陣</span><br>
  glGetFloatv( GL_PROJECTION_MATRIX, proj );</p>
<p> <span class="theme">//返回模型變換矩陣</span><br>
  glGetFloatv( GL_MODELVIEW_MATRIX, modl );</p>
<p> <span class="theme">//計算剪切矩陣，即上面兩個矩陣的乘積</span><br>
  clip[ 0] = modl[ 0] * proj[ 0] + modl[ 1] * proj[ 4] + modl[ 2] * proj[ 8] + 
  modl[ 3] * proj[12];<br>
  clip[ 1] = modl[ 0] * proj[ 1] + modl[ 1] * proj[ 5] + modl[ 2] * proj[ 9] + 
  modl[ 3] * proj[13];<br>
  clip[ 2] = modl[ 0] * proj[ 2] + modl[ 1] * proj[ 6] + modl[ 2] * proj[10] + 
  modl[ 3] * proj[14];<br>
  clip[ 3] = modl[ 0] * proj[ 3] + modl[ 1] * proj[ 7] + modl[ 2] * proj[11] + 
  modl[ 3] * proj[15];</p>
<p> clip[ 4] = modl[ 4] * proj[ 0] + modl[ 5] * proj[ 4] + modl[ 6] * proj[ 8] 
  + modl[ 7] * proj[12];<br>
  clip[ 5] = modl[ 4] * proj[ 1] + modl[ 5] * proj[ 5] + modl[ 6] * proj[ 9] + 
  modl[ 7] * proj[13];<br>
  clip[ 6] = modl[ 4] * proj[ 2] + modl[ 5] * proj[ 6] + modl[ 6] * proj[10] + 
  modl[ 7] * proj[14];<br>
  clip[ 7] = modl[ 4] * proj[ 3] + modl[ 5] * proj[ 7] + modl[ 6] * proj[11] + 
  modl[ 7] * proj[15];</p>
<p> clip[ 8] = modl[ 8] * proj[ 0] + modl[ 9] * proj[ 4] + modl[10] * proj[ 8] 
  + modl[11] * proj[12];<br>
  clip[ 9] = modl[ 8] * proj[ 1] + modl[ 9] * proj[ 5] + modl[10] * proj[ 9] + 
  modl[11] * proj[13];<br>
  clip[10] = modl[ 8] * proj[ 2] + modl[ 9] * proj[ 6] + modl[10] * proj[10] + 
  modl[11] * proj[14];<br>
  clip[11] = modl[ 8] * proj[ 3] + modl[ 9] * proj[ 7] + modl[10] * proj[11] + 
  modl[11] * proj[15];</p>
<p> clip[12] = modl[12] * proj[ 0] + modl[13] * proj[ 4] + modl[14] * proj[ 8] 
  + modl[15] * proj[12];<br>
  clip[13] = modl[12] * proj[ 1] + modl[13] * proj[ 5] + modl[14] * proj[ 9] + 
  modl[15] * proj[13];<br>
  clip[14] = modl[12] * proj[ 2] + modl[13] * proj[ 6] + modl[14] * proj[10] + 
  modl[15] * proj[14];<br>
  clip[15] = modl[12] * proj[ 3] + modl[13] * proj[ 7] + modl[14] * proj[11] + 
  modl[15] * proj[15];</p>
<p> <span class="theme">//提取右面的平面方程係數</span><br>
  m_Frustum[0][0] = clip[ 3] - clip[ 0];<br>
  m_Frustum[0][1] = clip[ 7] - clip[ 4];<br>
  m_Frustum[0][2] = clip[11] - clip[ 8];<br>
  m_Frustum[0][3] = clip[15] - clip[12];<br>
  t = GLfloat(sqrt( m_Frustum[0][0] * m_Frustum[0][0] + m_Frustum[0][1] * m_Frustum[0][1] 
  + m_Frustum[0][2] * m_Frustum[0][2] ));<br>
  m_Frustum[0][0] /= t;<br>
  m_Frustum[0][1] /= t;<br>
  m_Frustum[0][2] /= t;<br>
  m_Frustum[0][3] /= t;</p>
<p> <span class="theme">//提取左面的平面方程係數</span><br>
  m_Frustum[1][0] = clip[ 3] + clip[ 0];<br>
  m_Frustum[1][1] = clip[ 7] + clip[ 4];<br>
  m_Frustum[1][2] = clip[11] + clip[ 8];<br>
  m_Frustum[1][3] = clip[15] + clip[12];<br>
  t = GLfloat(sqrt( m_Frustum[1][0] * m_Frustum[1][0] + m_Frustum[1][1] * m_Frustum[1][1] 
  + m_Frustum[1][2] * m_Frustum[1][2] ));<br>
  m_Frustum[1][0] /= t;<br>
  m_Frustum[1][1] /= t;<br>
  m_Frustum[1][2] /= t;<br>
  m_Frustum[1][3] /= t;</p>
<p> <span class="theme">//提取下面的平面方程係數</span><br>
  m_Frustum[2][0] = clip[ 3] + clip[ 1];<br>
  m_Frustum[2][1] = clip[ 7] + clip[ 5];<br>
  m_Frustum[2][2] = clip[11] + clip[ 9];<br>
  m_Frustum[2][3] = clip[15] + clip[13];<br>
  t = GLfloat(sqrt( m_Frustum[2][0] * m_Frustum[2][0] + m_Frustum[2][1] * m_Frustum[2][1] 
  + m_Frustum[2][2] * m_Frustum[2][2] ));<br>
  m_Frustum[2][0] /= t;<br>
  m_Frustum[2][1] /= t;<br>
  m_Frustum[2][2] /= t;<br>
  m_Frustum[2][3] /= t;</p>
<p> <span class="theme">//提取上面的平面方程係數</span><br>
  m_Frustum[3][0] = clip[ 3] - clip[ 1];<br>
  m_Frustum[3][1] = clip[ 7] - clip[ 5];<br>
  m_Frustum[3][2] = clip[11] - clip[ 9];<br>
  m_Frustum[3][3] = clip[15] - clip[13];<br>
  t = GLfloat(sqrt( m_Frustum[3][0] * m_Frustum[3][0] + m_Frustum[3][1] * m_Frustum[3][1] 
  + m_Frustum[3][2] * m_Frustum[3][2] ));<br>
  m_Frustum[3][0] /= t;<br>
  m_Frustum[3][1] /= t;<br>
  m_Frustum[3][2] /= t;<br>
  m_Frustum[3][3] /= t;</p>
<p> <span class="theme">//提取遠面的平面方程係數</span><br>
  m_Frustum[4][0] = clip[ 3] - clip[ 2];<br>
  m_Frustum[4][1] = clip[ 7] - clip[ 6];<br>
  m_Frustum[4][2] = clip[11] - clip[10];<br>
  m_Frustum[4][3] = clip[15] - clip[14];<br>
  t = GLfloat(sqrt( m_Frustum[4][0] * m_Frustum[4][0] + m_Frustum[4][1] * m_Frustum[4][1] 
  + m_Frustum[4][2] * m_Frustum[4][2] ));<br>
  m_Frustum[4][0] /= t;<br>
  m_Frustum[4][1] /= t;<br>
  m_Frustum[4][2] /= t;<br>
  m_Frustum[4][3] /= t;</p>
<p> <span class="theme">//提取近面的平面方程係數</span><br>
  m_Frustum[5][0] = clip[ 3] + clip[ 2];<br>
  m_Frustum[5][1] = clip[ 7] + clip[ 6];<br>
  m_Frustum[5][2] = clip[11] + clip[10];<br>
  m_Frustum[5][3] = clip[15] + clip[14];<br>
  t = GLfloat(sqrt( m_Frustum[5][0] * m_Frustum[5][0] + m_Frustum[5][1] * m_Frustum[5][1] 
  + m_Frustum[5][2] * m_Frustum[5][2] ));<br>
  m_Frustum[5][0] /= t;<br>
  m_Frustum[5][1] /= t;<br>
  m_Frustum[5][2] /= t;<br>
  m_Frustum[5][3] /= t;<br>
  }</p>
<p></p>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
      <TD class=back3 vAlign=top width="100%">現在我們可以測試一個點或圓是否在視景體內了。下面的函數可以測試一個點是否在視景體內。</TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE>BOOL glCamera::PointInFrustum(glPoint p)<br>{<br>	int i;<br><br>	for(i = 0; i &lt; 6; i++)<br>	{<br>		if(m_Frustum[i][0] * p.x + m_Frustum[i][1] * p.y + m_Frustum[i][2] * p.z + m_Frustum[i][3] &lt;= 0)<br>		{<br>			return(FALSE);<br>		}<br>	}<br>	return(TRUE);<br>}</PRE>
<p></p>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=back3 vAlign=top width="100%"><p>下面的函數用來測試某個點是否位於當前場景物體的前面: </p>
        </TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE>bool glCamera::IsOccluded(glPoint p)<br>{<br>	GLint viewport[4];						<br>	GLdouble mvmatrix[16], projmatrix[16];  <br>	GLdouble winx, winy, winz;				<br>	GLdouble flareZ;						<br>	GLfloat bufferZ;						</PRE>
<p> glGetIntegerv (GL_VIEWPORT, viewport); <br>
  glGetDoublev (GL_MODELVIEW_MATRIX, mvmatrix); <br>
  glGetDoublev (GL_PROJECTION_MATRIX, projmatrix); </p>
<p> <span class="theme">// 返回頂點p在單位立方體中的位置</span><br>
  gluProject(p.x, p.y, p.z, mvmatrix, projmatrix, viewport, &amp;winx, &amp;winy, 
  &amp;winz);<br>
  flareZ = winz;</p>
<p> <span class="theme">// 讀取點(winx,winy)的深度坐標</span><br>
  glReadPixels(winx, winy,1,1,GL_DEPTH_COMPONENT, GL_FLOAT, &amp;bufferZ);</p>
<p> <span class="theme">// 如果深度坐標小於點的坐標，則返回true</span><br>
  if (bufferZ &lt; flareZ)<br>
  return true;<br>
  <span class="theme">//否則返回false</span><br>
  else<br>
  return false;<br>
  }</p>
<p></p>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
      <TD class=back3 vAlign=top width="100%">我們通過檢測光源是否正對我們的視線來決定是否繪製光暈，但如果你的視點超過了光源的位置，則會發生看不見光暈的現象。為了避免這種現象，我們在移動視點的使用，也相應的移動我們的光源。為了在視點和光源之間繪製多個光暈，我們需要計算之間的向量，下面的代碼完成這個功能：</TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE><span class="theme">//下面的函數完成具體的渲染光暈的任務</span><br>void glCamera::RenderLensFlare()<br>{<br>	GLfloat Length = 0.0f;</PRE>
<p> <span class="theme">// 如果我們的光源在我們的視線範圍內，則繪製它</span><br>
  if(SphereInFrustum(m_LightSourcePos, 1.0f) == TRUE)<br>
  {<br>
  vLightSourceToCamera = m_Position - m_LightSourcePos; <span class="theme">// 
  計算光源到我們視線的距離</span><br>
  Length = vLightSourceToCamera.Magnitude(); </p>
<p> <span class="theme">//下面三個函數計算光源位置到光暈結束位置之間的向量</span><br>
  ptIntersect = m_DirectionVector * Length; <br>
  ptIntersect += m_Position;<br>
  vLightSourceToIntersect = ptIntersect - m_LightSourcePos; <br>
  Length = vLightSourceToIntersect.Magnitude(); <br>
  vLightSourceToIntersect.Normalize(); <br>
  <br>
  glEnable(GL_BLEND); <br>
  glBlendFunc(GL_SRC_ALPHA, GL_ONE); <br>
  glDisable(GL_DEPTH_TEST); <br>
  glEnable(GL_TEXTURE_2D);</p>
<PRE>&nbsp;
</PRE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=back3 vAlign=top width="100%">
      <p>首先我們需要找到光源位置和視點位置之間的向量，接下來我們需要在視線的方向設置一個插值點，這個點的距離必須和光源位置和視點位置之間的距離相等。完成以後，我們找出可以產生光暈的方向，即下圖紅線的方向，在這個線上我們可以繪製我們的光暈。</p>
      <p>
        <center>
          <img src="../Pic/illustration.jpg" width="512" height="512">
        </center>
          <br>
      </p>
    </TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE>		if (!IsOccluded(m_LightSourcePos))	<span class="theme">//如果光暈可見</span><br>		{<br>			<span class="theme">// 渲染中間的光暈</span><br>			RenderBigGlow(0.60f, 0.60f, 0.8f, 1.0f, m_LightSourcePos, 16.0f);<br>			RenderStreaks(0.60f, 0.60f, 0.8f, 1.0f, m_LightSourcePos, 16.0f);<br>			RenderGlow(0.8f, 0.8f, 1.0f, 0.5f, m_LightSourcePos, 3.5f);</PRE>
<p> <span class="theme">//繪製到光暈結束位置的0.1處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.1f); <br>
  pt += m_LightSourcePos; <br>
  RenderGlow(0.9f, 0.6f, 0.4f, 0.5f, pt, 0.6f); </p>
<p> <span class="theme">//繪製到光暈結束位置的0.15處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.15f); <br>
  pt += m_LightSourcePos; <br>
  RenderHalo(0.8f, 0.5f, 0.6f, 0.5f, pt, 1.7f); <br>
  <br>
  <span class="theme">//繪製到光暈結束位置的0.175處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.175f); <br>
  pt += m_LightSourcePos; <br>
  RenderHalo(0.9f, 0.2f, 0.1f, 0.5f, pt, 0.83f); </p>
<p> <span class="theme">//繪製到光暈結束位置的0.285處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.285f); <br>
  pt += m_LightSourcePos; <br>
  RenderHalo(0.7f, 0.7f, 0.4f, 0.5f, pt, 1.6f); <br>
  <br>
  <span class="theme">//繪製到光暈結束位置的0.2755處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.2755f); <br>
  pt += m_LightSourcePos; <br>
  RenderGlow(0.9f, 0.9f, 0.2f, 0.5f, pt, 0.8f); </p>
<p> <span class="theme">//繪製到光暈結束位置的0.4755處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.4775f); <br>
  pt += m_LightSourcePos; <br>
  RenderGlow(0.93f, 0.82f, 0.73f, 0.5f, pt, 1.0f); <br>
  <br>
  <span class="theme">//繪製到光暈結束位置的0.49處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.49f); <br>
  pt += m_LightSourcePos; <br>
  RenderHalo(0.7f, 0.6f, 0.5f, 0.5f, pt, 1.4f); </p>
<p> <span class="theme">//繪製到光暈結束位置的0.65處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.65f); <br>
  pt += m_LightSourcePos; <br>
  RenderGlow(0.7f, 0.8f, 0.3f, 0.5f, pt, 1.8f); <br>
  <br>
  <span class="theme">//繪製到光暈結束位置的0.63處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.63f); <br>
  pt += m_LightSourcePos; <br>
  RenderGlow(0.4f, 0.3f, 0.2f, 0.5f, pt, 1.4f); </p>
<p> <span class="theme">//繪製到光暈結束位置的0.8處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.8f); <br>
  pt += m_LightSourcePos; <br>
  RenderHalo(0.7f, 0.5f, 0.5f, 0.5f, pt, 1.4f); <br>
  <br>
  <span class="theme">//繪製到光暈結束位置的0.7825處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.7825f); <br>
  pt += m_LightSourcePos; <br>
  RenderGlow(0.8f, 0.5f, 0.1f, 0.5f, pt, 0.6f); </p>
<p> <span class="theme">//繪製到光暈結束位置的1.0處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 1.0f); <br>
  pt += m_LightSourcePos; <br>
  RenderHalo(0.5f, 0.5f, 0.7f, 0.5f, pt, 1.7f); <br>
  <br>
  <span class="theme">//繪製到光暈結束位置的0.975處的光暈</span><br>
  pt = vLightSourceToIntersect * (Length * 0.975f); <br>
  pt += m_LightSourcePos; <br>
  RenderGlow(0.4f, 0.1f, 0.9f, 0.5f, pt, 2.0f); </p>
<p> }<br>
  glDisable(GL_BLEND ); <br>
  glEnable(GL_DEPTH_TEST); <br>
  glDisable(GL_TEXTURE_2D); <br>
  }<br>
  }</p>
<p></p>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
      <TD class=back3 vAlign=top width="100%">好了，下面的函數用來繪製四種不同的光暈</TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE><span class="theme">//繪製Halo形的光暈</span><br>void glCamera::RenderHalo(GLfloat r, GLfloat g, GLfloat b, GLfloat a, glPoint p, GLfloat scale)<br>{<br>	glPoint q[4];<br>	<br>	q[0].x = (p.x - scale);											<br>	q[0].y = (p.y - scale);											<br>		<br>	q[1].x = (p.x - scale);											<br>	q[1].y = (p.y + scale);											<br>		<br>	q[2].x = (p.x + scale);											<br>	q[2].y = (p.y - scale);											<br>		<br>	q[3].x = (p.x + scale);											<br>	q[3].y = (p.y + scale);											<br>		<br>	glPushMatrix();													<br>	glTranslatef(p.x, p.y, p.z);									<br>	glRotatef(-m_HeadingDegrees, 0.0f, 1.0f, 0.0f);<br>	glRotatef(-m_PitchDegrees, 1.0f, 0.0f, 0.0f);<br>	glBindTexture(GL_TEXTURE_2D, m_HaloTexture);					<br>	glColor4f(r, g, b, a);											<br>	<br>	glBegin(GL_TRIANGLE_STRIP);										<br>		glTexCoord2f(0.0f, 0.0f);					<br>		glVertex2f(q[0].x, q[0].y);<br>		glTexCoord2f(0.0f, 1.0f);<br>		glVertex2f(q[1].x, q[1].y);<br>		glTexCoord2f(1.0f, 0.0f);<br>		glVertex2f(q[2].x, q[2].y);<br>		glTexCoord2f(1.0f, 1.0f);<br>		glVertex2f(q[3].x, q[3].y);<br>	glEnd();										<br>	glPopMatrix();													<br>}</PRE>
<p><span class="theme">//繪製Gloew形的光暈</span><br>
  void glCamera::RenderGlow(GLfloat r, GLfloat g, GLfloat b, GLfloat a, glPoint 
  p, GLfloat scale)<br>
  {<br>
  glPoint q[4];<br>
  <br>
  q[0].x = (p.x - scale); <br>
  q[0].y = (p.y - scale); </p>
<p> q[1].x = (p.x - scale); <br>
  q[1].y = (p.y + scale); <br>
  <br>
  q[2].x = (p.x + scale); <br>
  q[2].y = (p.y - scale); <br>
  <br>
  q[3].x = (p.x + scale); <br>
  q[3].y = (p.y + scale); <br>
  <br>
  glPushMatrix(); <br>
  glTranslatef(p.x, p.y, p.z); <br>
  glRotatef(-m_HeadingDegrees, 0.0f, 1.0f, 0.0f);<br>
  glRotatef(-m_PitchDegrees, 1.0f, 0.0f, 0.0f);<br>
  glBindTexture(GL_TEXTURE_2D, m_GlowTexture); <br>
  glColor4f(r, g, b, a); <br>
  <br>
  glBegin(GL_TRIANGLE_STRIP); <br>
  glTexCoord2f(0.0f, 0.0f); <br>
  glVertex2f(q[0].x, q[0].y);<br>
  glTexCoord2f(0.0f, 1.0f);<br>
  glVertex2f(q[1].x, q[1].y);<br>
  glTexCoord2f(1.0f, 0.0f);<br>
  glVertex2f(q[2].x, q[2].y);<br>
  glTexCoord2f(1.0f, 1.0f);<br>
  glVertex2f(q[3].x, q[3].y);<br>
  glEnd(); <br>
  glPopMatrix(); <br>
  }</p>
<p><span class="theme">//繪製BigGlow形的光暈</span><br>
  void glCamera::RenderBigGlow(GLfloat r, GLfloat g, GLfloat b, GLfloat a, glPoint 
  p, GLfloat scale)<br>
  {<br>
  glPoint q[4];<br>
  <br>
  q[0].x = (p.x - scale); <br>
  q[0].y = (p.y - scale); <br>
  <br>
  q[1].x = (p.x - scale); <br>
  q[1].y = (p.y + scale); <br>
  <br>
  q[2].x = (p.x + scale); <br>
  q[2].y = (p.y - scale); <br>
  <br>
  q[3].x = (p.x + scale); <br>
  q[3].y = (p.y + scale); <br>
  <br>
  glPushMatrix(); <br>
  glTranslatef(p.x, p.y, p.z); <br>
  glRotatef(-m_HeadingDegrees, 0.0f, 1.0f, 0.0f);<br>
  glRotatef(-m_PitchDegrees, 1.0f, 0.0f, 0.0f);<br>
  glBindTexture(GL_TEXTURE_2D, m_BigGlowTexture); <br>
  glColor4f(r, g, b, a); <br>
  <br>
  glBegin(GL_TRIANGLE_STRIP); <br>
  glTexCoord2f(0.0f, 0.0f); <br>
  glVertex2f(q[0].x, q[0].y);<br>
  glTexCoord2f(0.0f, 1.0f);<br>
  glVertex2f(q[1].x, q[1].y);<br>
  glTexCoord2f(1.0f, 0.0f);<br>
  glVertex2f(q[2].x, q[2].y);<br>
  glTexCoord2f(1.0f, 1.0f);<br>
  glVertex2f(q[3].x, q[3].y);<br>
  glEnd(); <br>
  glPopMatrix(); <br>
  }</p>
<p><span class="theme">//繪製Streaks形的光暈</span><br>
  void glCamera::RenderStreaks(GLfloat r, GLfloat g, GLfloat b, GLfloat a, glPoint 
  p, GLfloat scale)<br>
  {<br>
  glPoint q[4];<br>
  <br>
  q[0].x = (p.x - scale); <br>
  q[0].y = (p.y - scale); <br>
  <br>
  q[1].x = (p.x - scale); <br>
  q[1].y = (p.y + scale); <br>
  <br>
  q[2].x = (p.x + scale); <br>
  q[2].y = (p.y - scale); <br>
  <br>
  q[3].x = (p.x + scale); <br>
  q[3].y = (p.y + scale); <br>
  <br>
  glPushMatrix(); <br>
  glTranslatef(p.x, p.y, p.z); <br>
  glRotatef(-m_HeadingDegrees, 0.0f, 1.0f, 0.0f);<br>
  glRotatef(-m_PitchDegrees, 1.0f, 0.0f, 0.0f);<br>
  glBindTexture(GL_TEXTURE_2D, m_StreakTexture); <br>
  glColor4f(r, g, b, a); <br>
  <br>
  glBegin(GL_TRIANGLE_STRIP); <br>
  glTexCoord2f(0.0f, 0.0f); <br>
  glVertex2f(q[0].x, q[0].y);<br>
  glTexCoord2f(0.0f, 1.0f);<br>
  glVertex2f(q[1].x, q[1].y);<br>
  glTexCoord2f(1.0f, 0.0f);<br>
  glVertex2f(q[2].x, q[2].y);<br>
  glTexCoord2f(1.0f, 1.0f);<br>
  glVertex2f(q[3].x, q[3].y);<br>
  glEnd(); <br>
  glPopMatrix(); <br>
  }<br>
</p>
<p></p>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=tl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=tc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
    width="100%"></TD>
    <TD class=tr><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=l><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
      <TD class=back3 vAlign=top width="100%"><p>你可以使用w,s,a,d變換攝像機的方向，1，2顯示/關閉各種信息參數。C給攝像機一個固定的速度，X停止它。</p>
        <p>上面就是這個教程的全部了，所有的問題，評論和抱怨都歡迎。當然我不是第一個作這個效果的人，下面是其他方面相關的文章:<br>
          <a href="http://www.gamedev.net/reference/articles/article874.asp">http://www.gamedev.net/reference/articles/article874.asp</a><br>
          <a href="http://www.gamedev.net/reference/articles/article813.asp">http://www.gamedev.net/reference/articles/article813.asp</a><br>
          <a href="http://www.opengl.org/developers/code/mjktips/lensflare/">http://www.opengl.org/developers/code/mjktips/lensflare/</a><br>
          <a href="http://www.markmorley.com/opengl/frustumculling.html">http://www.markmorley.com/opengl/frustumculling.html</a><br>
          <a href="http://oss.sgi.com/projects/ogl-sample/registry/HP/occlusion_test.txt">http://oss.sgi.com/projects/ogl-sample/registry/HP/occlusion_test.txt</a><br>
          <a href="http://oss.sgi.com/projects/ogl-sample/registry/NV/occlusion_query.txt">http://oss.sgi.com/projects/ogl-sample/registry/NV/occlusion_query.txt</a> 
        </p>
<table width="100%" border="1">
  <tr>
    <td width="27%"><img src="../images/logo%203.jpg" width="209" height="200" align="middle"></td>
    <td width="73%">版權與使用聲明:<br>
      我是個對學習和生活充滿激情的普通男孩,在網絡上我以DancingWind為暱稱，我的聯繫方式是zhouwei02@mails.tsinghua.edu.cn，如果你有任何問題，都可以聯繫我。
      <p>引子<br>
        網絡是一個共享的資源，但我在自己的學習生涯中浪費大量的時間去搜索可用的資料，在現實生活中花費了大量的金錢和時間在書店中尋找資料，於是我給自己起了個暱稱DancingWind，其意義是想風一樣從各個知識的站點中吸取成長的養料。在飄蕩了多年之後，我決定把自己收集的資料整理為一個統一的資源庫。</p>
      <p>版權聲明<br>
        所有DancingWind發表的內容，大多都來自共享的資源，所以我沒有資格把它們據為己有，或聲稱自己為這些資源作出了一點貢獻。故任何人都可以複製，修改，重新發表，甚至以自己的名義發表，我都不會追究，但你在做以上事情的時候必須保證內容的完整性，給後來的人一個完整的教程。最後，任何人不能以這些資料的任何部分，謀取任何形式的報酬。</p>
      <p>發展計劃<br>
        在國外，很多資料都是很多人花費幾年的時間慢慢積累起來的。如果任何人有興趣與別人共享你的知識，我很歡迎你與我聯繫，但你必須同意我上面的聲明。</p>
              <p>感謝<br>
                感謝我的母親一直以來對我的支持和在生活上的照顧。<br>
                感謝我深愛的女友田芹，一直以來默默的在精神上和生活中對我的支持，她甚至把買衣服的錢都用來給我買書了，她真的是我見過的最好的女孩，希望我能帶給她幸福。</p>
              <p>資源下載: <br>
                文檔 <a href="http://www.alucardma.com/dancingwind/OpenGL/Nehe/Res/mht/NeHe%20OpenGL%20Chinese%20Course%2044.mht">網頁格式</a> 
                <a href="http://www.alucardma.com/dancingwind/OpenGL/Nehe/Res/pdf/OpenGL_Nehe_Course_Tutorial_44.pdf">PDF格式</a><br>
                源碼 <a href="http://www.alucardma.com/dancingwind/OpenGL/Nehe/Res/Src/44_Flare.rar">RAR格式</a></p></td>
  </tr>
</table>
        <FONT class=text>
        <TABLE width="100%" border=0>
          <TBODY>
            <TR> 
              <TD align=left width="50%"><B><FONT size=-1><A 
            href="Tutorial_43.html">&lt; 第43課</A></FONT></B></TD>
              <TD align=right width="50%"><B><FONT 
        size=-1><a href="Tutorial_45.html">第45課 &gt;&nbsp;</a></FONT></B></TD>
            </TR>
          </TBODY>
        </TABLE>
        </FONT> </TD>
    <TD class=r><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=bl><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=bc width="100%"><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" width=28></TD>
    <TD class=br><IMG height=28 alt="" 
      src="../Pic/blank(1).gif" 
  width=28></TD></TR></TBODY></TABLE>
<PRE>&nbsp;</PRE>
</BODY>
<!-- Mirrored from www.alucardma.com/dancingwind/OpenGL/Nehe/Course/Tutorial_44.htm by HTTrack Website Copier/3.x [XR&CO'2006], Sat, 25 Nov 2006 10:05:22 GMT -->
</HTML>
